/**
 * AI Attribution Detection (in-process, regex-based)
 *
 * Scans file patches and commit messages for AI attribution patterns.
 * Runs entirely in-process with no external dependencies (~10ms).
 */

import type { StaticAnalysisFinding } from './types.ts';

/** AI attribution patterns (case-insensitive) */
const AI_PATTERNS: RegExp[] = [
  /co-authored-by:.*claude/i,
  /co-authored-by:.*anthropic/i,
  /co-authored-by:.*gpt/i,
  /co-authored-by:.*openai/i,
  /co-authored-by:.*copilot/i,
  /co-authored-by:.*gemini/i,
  /co-authored-by:.*\bai\b/i,
  /made by claude/i,
  /made by gpt/i,
  /made by ai/i,
  /made with claude/i,
  /made with ai/i,
  /generated by claude/i,
  /generated by gpt/i,
  /generated by ai/i,
  /generated with claude/i,
  /generated with ai/i,
  /written by claude/i,
  /written by ai/i,
  /created by claude/i,
  /created by ai/i,
  /assisted by claude/i,
  /assisted by ai/i,
  /with help from claude/i,
  /claude code/i,
  /claude opus/i,
  /claude sonnet/i,
  /claude haiku/i,
  /gpt-4/i,
  /gpt-3/i,
  /chatgpt/i,
  /@anthropic\.com/i,
  /@openai\.com/i,
  /noreply@anthropic/i,
  /noreply@openai/i,
];

/**
 * Check a file's patch (diff) for AI attribution patterns.
 * Only scans added lines (lines starting with '+').
 */
export function checkFileForAiAttribution(
  filename: string,
  patch: string
): StaticAnalysisFinding[] {
  const findings: StaticAnalysisFinding[] = [];

  if (!patch) return findings;

  const lines = patch.split('\n');

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    // Only check added lines
    if (!line.startsWith('+') || line.startsWith('+++')) continue;

    const content = line.slice(1); // Remove the leading '+'

    for (const pattern of AI_PATTERNS) {
      if (pattern.test(content)) {
        // Try to extract a line number from the hunk header
        const lineNumber = getLineNumberFromPatch(lines, i);

        findings.push({
          severity: 'error',
          category: 'ai-attribution',
          message: `AI attribution detected: "${content.trim()}"`,
          file: filename,
          line: lineNumber,
          suggestion: 'Remove AI attribution from the code.',
          source: 'static-analysis',
          ruleId: 'ai-attribution-file',
        });
        break; // One finding per line is enough
      }
    }
  }

  return findings;
}

/**
 * Try to determine the actual file line number from a patch hunk context.
 */
function getLineNumberFromPatch(lines: string[], currentIndex: number): number | undefined {
  // Walk backwards to find the nearest @@ hunk header
  let addedLineCount = 0;
  for (let i = currentIndex; i >= 0; i--) {
    if (lines[i].startsWith('@@')) {
      // Parse @@ -old,count +new,count @@
      const match = lines[i].match(/@@ -\d+(?:,\d+)? \+(\d+)/);
      if (match) {
        const startLine = parseInt(match[1], 10);
        return startLine + addedLineCount - 1;
      }
      return undefined;
    }
    // Count lines that exist in the new file (added or context lines)
    if (!lines[i].startsWith('-')) {
      addedLineCount++;
    }
  }
  return undefined;
}

/** Commit info for attribution checking */
export interface CommitInfo {
  sha: string;
  message: string;
}

/**
 * Check commit messages for AI attribution patterns.
 * Includes fix suggestions based on commit position.
 */
export function checkCommitsForAiAttribution(
  commits: CommitInfo[],
  totalCommits: number
): StaticAnalysisFinding[] {
  const findings: StaticAnalysisFinding[] = [];

  for (let idx = 0; idx < commits.length; idx++) {
    const commit = commits[idx];

    for (const pattern of AI_PATTERNS) {
      if (pattern.test(commit.message)) {
        const shortSha = commit.sha.slice(0, 7);
        const isLastCommit = idx === commits.length - 1;

        let suggestion: string;
        if (isLastCommit && commits.length === 1) {
          suggestion =
            `Fix: \`git commit --amend -m "your clean message"\` then \`git push --force-with-lease\``;
        } else if (isLastCommit) {
          suggestion =
            `Fix (last commit): \`git commit --amend -m "your clean message"\` then \`git push --force-with-lease\``;
        } else {
          suggestion =
            `Fix: \`git rebase -i ${commit.sha}~1\`, change \`pick\` to \`reword\`, then \`git push --force-with-lease\``;
        }

        findings.push({
          severity: 'error',
          category: 'ai-attribution',
          message: `AI attribution in commit \`${shortSha}\`: "${commit.message.split('\n')[0]}"`,
          suggestion,
          source: 'static-analysis',
          ruleId: 'ai-attribution-commit',
        });
        break; // One finding per commit
      }
    }
  }

  return findings;
}
